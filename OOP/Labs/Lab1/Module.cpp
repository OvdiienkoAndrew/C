#include "Module.h" // Підключення хедер-файлу.

Array::Array() {
    poz = 0; // Ініціалізуємо кількість позитивних чисел.
    neg = 0; // Ініціалізуємо кількість негативних чисел.
    zer = 0; // Ініціалізуємо кількість нульових чисел.
    size = 0; // Ініціалізуємо розмір масиву.
    A = nullptr; // Ініціалізуємо вказівник на масив.
    choice = '\0'; // Ініціалізуємо вибір користувача.
    filename2 = nullptr;  // Ініціалізуємо ім'я файлу у рядку.
}

Array::Array(int argc, char* argv[]){
    size = 0; // Ініціалізуємо розмір масиву.
    poz = 0; // Ініціалізуємо кількість позитивних чисел.
    neg = 0; // Ініціалізуємо кількість негативних чисел.
    zer = 0; // Ініціалізуємо кількість нульових чисел.
    A = nullptr; // Ініціалізуємо вказівник на масив.
    if(argc > 1) A = new double[strlen(argv[argc-1])]; // Якщо кількість аргументів командного рядка більша за 1, виділяємо пам'ять під масив.
    choice = '\0'; // Ініціалізуємо вибір користувача.
    filename2 = nullptr; // Ініціалізуємо ім'я файлу у рядку.
}

void Array::show(){
    if(size > 0){ // Перевіряємо, чи є елементи у масиві.
        cout << "\nОтримана послідовність чисел:\n"; // Виводимо заголовок послідовності чисел.
        for(int i=0; i<size; i++){ // Проходимося по всіх елементах масиву.
            cout << setw(10) << i+1 << ". " << setw(10) << A[i]; // Виводимо номер і значення кожного елемента масиву.
            if(i+1==size) cout << ".\n"; // Якщо це останній елемент, виводимо крапку.
            else cout << ";\n"; // Інакше виводимо крапку з комою.
        }
    }
    else cout << "\nНемає елементів\n"; // Виводимо повідомлення про відсутність елементів у масиві.
}

void Array::ilessone(){
    size = 0; // Ініціалізуємо розмір масиву.
    char filename[256]; // Оголошення рядка для зберігання імені файлу.
    ifstream f; // Оголошення потоку для зчитування з файлу.
    cout << "\nВведіть імʼя файлу, з якого ви хочете взяти дані.\nФайл (путь до нього): "; // Виводимо запит на введення імені файлу.
    while (cin >> filename, f.open(filename, ios::in), f.fail() || f.eof() || f.bad()) // Продовжуємо читати ім'я файлу та відкривати файл, поки відкриття не вдасться або файл пустий або сталася інша помилка.
        cout << "\nНе можу відкрити файл: " << filename << ". Спробуєте ще раз? ;)\nФайл: "; // Виводимо повідомлення про невдале відкриття файлу.

    char line[255]; // Оголошення рядка для зберігання зчитаного рядка з файлу.
    while (f.getline(line, sizeof(line))){ // Перебираємо кожен рядок у файлі.
        if (line[0] != '\0'){  // Перевіряємо, чи рядок не порожній.
            char* endPtr; // Вказівник на кінець рядка для перетворення рядка на число.
            double num = strtod(line, &endPtr); // Конвертуємо рядок у число типу double.
            if (endPtr != line) { // Перевіряємо, чи рядок був успішно перетворений у число.
                double *temp = new double[size + 1]; // Виділяємо пам'ять під тимчасовий масив.
                for (int j = 0; j < size; j++) // Копіюємо попередні елементи масиву у тимчасовий масив.
                    temp[j] = A[j];
                temp[size] = num; // Додаємо нове число до кінця тимчасового масиву.
                delete[] A;  // Звільняємо пам'ять, виділену для попереднього масиву.
                A = temp; // Призначаємо масиву посилання на тимчасовий масив.
                size++; // Збільшуємо розмір масиву.
            }
        }
    }
    f.close(); // Закриваємо файл.
    if(size <= 0){ // Перевіряємо, чи розмір масиву не менше 0.
        cin.clear(); // Очищуємо стан потоку вводу.
        cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Ігноруємо залишкові символи вводу.
        cout << "\nНемає жодного елемента у файлі.\nЗауважте, що числа у файлі (дробні) мають бути записані через крапку, а вже різні числа за значення - або через пробіл, або з нового рядка.\nЯкщо число у файлі не є числом, а є символом, то це число не буде записано.\n"; // Виводимо повідомлення про відсутність чисел у файлі та надаємо інструкції щодо правильного формату чисел у файлі.
        filename2 = nullptr; // Встановлюємо значення filename2 як nullptr.
        ilessone(); // Викликаємо функцію знову для повторного введення файлу.
    }
}

void Array::argcmoreone(int argc, char* argv[]){
    ifstream file(argv[argc - 1]); // Відкриваємо файл, який переданий як аргумент командного рядка.

    if (file.is_open()) { // Перевіряємо, чи файл вдало відкрито.
        file.close(); // Закриваємо файл.
        size = argc - 2; // Встановлюємо розмір масиву як кількість аргументів командного рядка, за винятком останнього (який є ім'ям файлу).
        filename2 = argv[argc-1]; // Запам'ятовуємо ім'я файлу.
    } else { // Інакше.
        size = argc - 1; // Якщо файл не вдалося відкрити, розмір масиву буде рівний кількості аргументів командного рядка.
        filename2 = nullptr; // Якщо файл не вдалося відкрити, ім'я файлу залишається нульовим вказівником.
    }
    
    if(size <= 0) // Перевіряємо, чи розмір масиву не менше 0.
        ilessone(); // Якщо розмір масиву менше або дорівнює 0, викликаємо функцію для введення даних з консолі.
    else { // Інакше.
        A = new double[size]; // Виділяємо пам'ять під масив.
        int validNumbers = 0; // Лічильник коректних чисел.
        for (int i = 0; i < size; ++i){ // Перебираємо всі аргументи командного рядка.
            char* endPtr; // Вказівник на кінець рядка для перетворення рядка на число.
            double num = strtod(argv[i + 1], &endPtr); // Конвертуємо аргумент у число типу double.
            if (*endPtr == '\0'){ // Перевіряємо, чи аргумент був успішно перетворений у число.
                A[validNumbers] = num; // Записуємо число у масив.
                validNumbers++; // Збільшуємо лічильник коректних чисел.
            }
        }
        size = validNumbers; // Оновлюємо розмір масиву як кількість коректних чисел.
    }
}

void Array::zerotask(int argc, char* argv[]){
    if(argc <= 1) // Перевіряємо, чи кількість аргументів командного рядка менше або дорівнює 1.
        ilessone(); // Якщо умова виконується, викликаємо функцію для введення даних з консолі.
    else argcmoreone(argc, argv); // Інакше викликаємо функцію для обробки аргументів командного рядка.
    show(); // Відображаємо отриману послідовність чисел.
}

void Array::merge(int &l, int &m, int &r){
    int n1 = m - l + 1; // Обчислюємо розмір лівого підмасиву.
    int n2 = r - m; // Обчислюємо розмір правого підмасиву.
    double L[n1], R[n2]; // Створюємо тимчасові масиви для лівого та правого підмасивів.
    
    // Копіюємо елементи з основного масиву до тимчасових масивів.
    for (int i = 0; i < n1; i++)  // Проходимо по лівому підмасиву.
        L[i] = A[l + i]; // Копіюємо елементи з основного масиву до тимчасового лівого підмасиву.
    for (int j = 0; j < n2; j++)  // Проходимо по правому підмасиву.
        R[j] = A[m + 1 + j]; // Копіюємо елементи з основного масиву до тимчасового правого підмасиву.
    
    int i = 0, j = 0, k = l; // Ініціалізуємо індекси для обох підмасивів та основного масиву.
    while (i < n1 && j < n2)  // Об'єднуємо лівий та правий підмасиви у відсортований масив.
    {
        if (L[i] >= R[j]) // Порівнюємо елементи лівого та правого підмасивів.
        {
            A[k] = L[i]; // Якщо елемент з лівого підмасиву більший, записуємо його у основний масив.
            i++; // Переходимо до наступного елемента лівого підмасиву.
        }
        else // Інакше.
        {
            A[k] = R[j]; // Якщо елемент з правого підмасиву більший, записуємо його у основний масив.
            j++; // Переходимо до наступного елемента правого підмасиву.
        }
        k++; // Переходимо до наступного індексу основного масиву.
    }
    while (i < n1) // Копіюємо залишок елементів з лівого підмасиву, якщо такі є.
    {
        A[k] = L[i]; // Копіюємо залишок елементів з лівого підмасиву у основний масив.
        i++; // Переходимо до наступного елемента лівого підмасиву.
        k++; // Переходимо до наступного індексу основного масиву.
    }
    while (j < n2)  // Копіюємо залишок елементів з правого підмасиву, якщо такі є.
    {
        A[k] = R[j]; // Копіюємо залишок елементів з правого підмасиву у основний масив.
        j++; // Переходимо до наступного елемента правого підмасиву.
        k++; // Переходимо до наступного індексу основного масиву.
    }
}

void Array::mergeSort(int l, int r) {
    if (l < r) { // Перевіряємо, чи ліва границя менша за праву.
        int m = l + (r - l) / 2; // Знаходимо середину масиву.
        mergeSort(l, m); // Сортуємо ліву половину масиву.
        mergeSort(m + 1, r); // Сортуємо праву половину масиву.
        merge(l, m, r); // Об'єднуємо відсортовані підмасиви.
    }
}

void Array::firsttask(){
    mergeSort(0, size-1); // Викликаємо функцію сортування злиттям для впорядкування масиву.
    cout << "\nУпорядковуємо надану послідовність за критерієм \"Спочатку гарні(позитивні) потім погані (негативні)\".\n"; // Виводимо повідомлення про впорядкування за певним критерієм.
    show(); // Виводимо впорядковану послідовність чисел.
}

void Array::secondtask(){
    for(int i=0; i<size; i++){ // Проходимо по всім елементам масиву.
        if(A[i] > 0) poz++; // Підраховуємо кількість позитивних чисел.
        else if (A[i] == 0) zer++; // Підраховуємо кількість нульових чисел.
        else neg++; // Підраховуємо кількість негативних чисел.
    }
    cout << "\nКількість гарних (позитивних): " << poz << ";\nКількість ніяких (нульові): " << zer << ";\nКількість поганих (негативних): " << neg << ".\n"; // Виводимо кількість позитивних, нульових та негативних чисел.
}

void Array::lasttask() {
    ofstream f; // Об'єкт для роботи з файлом.
    char filename[255]; // Масив для збереження імені файлу.
    char choice2 = '\0'; // Змінна для вибору користувача.

    if(filename2 == nullptr) { // Перевіряємо, чи задано ім'я файлу для запису результатів.
        do { // Початок виконуваного циклу.
            cout << "\nЗаносити дані у файл? y/n\n"; // Виводимо запит на вибір користувача.
            cin >> choice; // Зчитуємо вибір користувача.

            switch(choice) { // Обробка вибору користувача.
                case 'n': // Вибір користувача - "ні".
                    break; // Вихід із циклу.

                case 'y': // Вибір користувача - "так".
                    cout << "\nВведіть файл, у який записати результат.\nФайл (путь до нього): "; // Виводимо запит на введення імені файлу.

                    // Відкриваємо файл для запису результатів.
                    while (cin >> filename, f.open(filename, ios::app), f.fail() || f.bad()) { // Повторюємо спроби відкриття файлу, доки це не вдасться.
                        cout << "\nНе можу відкрити файл: " << filename << ". Спробуєте ще раз? ;)\nФайл (путь до нього): "; // Повідомлення про помилку відкриття файлу.
                        f.clear(); // Скидаємо стан помилки у потоку.
                    }
                    if(size > 0) { // Якщо в масиві є елементи
                        // Записуємо відсортовану послідовність у файл.
                        f << "\n\n\nУпорядковуємо надану послідовність за критерієм \"Спочатку гарні(позитивні) потім погані (негативні)\":\n"; // Виводимо повідомлення про впорядкування за певним критерієм.
                        for(int i = 0; i < size; i++) { // Проходимося по елементам масиву.
                            f << setw(10) << i + 1 << ". " << setw(10) << A[i]; // Записуємо елемент у файл.
                            if(i + 1 == size) f << ".\n"; // Якщо це останній елемент, додаємо крапку і переводимо рядок.
                            else f << ";\n"; // Інакше додаємо крапку з комою і переводимо рядок.
                        }
                        // Записуємо кількість позитивних, нульових та негативних чисел у файл.
                        f << "\nКількість гарних (позитивних): " << poz << ";\nКількість ніяких (нульових): " << zer << ";\nКількість поганих (негативних): " << neg << ".\n"; // Виводимо кількість позитивних, нульових та негативних чисел.
                    } else { // Інакше
                        f << "\nНемає елементів\n"; // Записуємо повідомлення про відсутність елементів у файлі.
                    }
                    f.close(); // Закриваємо файл.
                    break; // Вихід із циклу.
            }
        } while(choice != 'y' && choice != 'n'); // Повторюємо цикл, доки користувач не вибере 'y' або 'n'.
    } else { // Інакше.
        do { // Початок виконуваного циклу.
            cout << "\nЗаносити дані у файл в " << filename2 << "? y/n\n"; // Виводимо запит на вибір користувача.
            cin >> choice; // Зчитуємо вибір користувача.

            switch(choice) { // Обробка вибору користувача.
                case 'n': // Вибір користувача - "ні".
                    do { // Початок виконуваного циклу.
                        cout << "\nЗаносити дані у файл? y/n\n"; // Виводимо запит на вибір користувача.
                        cin >> choice2; // Зчитуємо вибір користувача.
                        switch(choice2) { // Обробка вибору користувача.
                            case 'n': // Вибір користувача - "ні".
                                break; // Вихід із циклу.
                            case 'y': // Вибір користувача - "так".
                                cout << "\nВведіть файл, у який записати результат.\nФайл (путь до нього): "; // Виводимо запит на введення імені файлу.

                                // Відкриваємо файл для запису результатів.
                                while (cin >> filename, f.open(filename, ios::app), f.fail() || f.bad()) { // Повторюємо спроби відкриття файлу, доки це не вдасться.
                                    cout << "\nНе можу відкрити файл: " << filename << ". Спробуєте ще раз? ;)\nФайл (путь до нього): "; // Повідомлення про помилку відкриття файлу.
                                    f.clear(); // Скидаємо стан помилки у потоку.
                                }
                                if(size > 0) { // Якщо в масиві є елементи.
                                    // Записуємо відсортовану послідовність у файл.
                                    f << "\n\n\nУпорядковуємо надану послідовність за критерієм \"Спочатку гарні(позитивні) потім погані (негативні)\":\n"; // Виводимо повідомлення про впорядкування за певним критерієм.
                                    for(int i = 0; i < size; i++) { // Проходимося по елементам масиву.
                                        f << setw(10) << i + 1 << ". " << setw(10) << A[i]; // Записуємо елемент у файл.
                                        if(i + 1 == size) f << ".\n"; // Якщо це останній елемент, додаємо крапку і переводимо рядок.
                                        else f << ";\n"; // Інакше додаємо крапку з комою і переводимо рядок.
                                    }
                                    // Записуємо кількість позитивних, нульових та негативних чисел у файл.
                                    f << "\nКількість гарних (позитивних): " << poz << ";\nКількість ніяких (нульових): " << zer << ";\nКількість поганих (негативних): " << neg << ".\n"; // Виводимо кількість позитивних, нульових та негативних чисел.
                                } else { // Інакше.
                                    f << "\nНемає елементів\n"; // Записуємо повідомлення про відсутність елементів у файлі.
                                }
                                f.close(); // Закриваємо файл.
                                break; // Вихід із циклу.
                        }
                    } while(choice2 != 'y' && choice2 != 'n');  // Повторюємо цикл, доки користувач не вибере 'y' або 'n'.
                    break;  // Вихід із циклу.

                case 'y':  // Вибір користувача - "так".
                    f.open(filename2, ios::app); // Відкриваємо файл для запису результатів.

                    if(!f.is_open()) { // Перевіряємо, чи не вдалося відкрити файл.
                        cout << "\nПомилка відкриття файла.\nВведіть файл, у який записати результат.\nФайл (путь до нього): "; // Виводимо повідомлення про помилку відкриття файлу.

                        // Знову запитуємо ім'я файлу, поки не відкриється правильно.
                        while (cin >> filename, f.open(filename, ios::app), f.fail() || f.bad()) { // Повторюємо спроби відкриття файлу, доки це не вдасться.
                            cout << "\nНе можу відкрити файл: " << filename << ". Спробуєте ще раз? ;)\nФайл (путь до нього): "; // Виводимо повідомлення про невдале відкриття файлу.
                            f.clear(); // Скидаємо стан помилки у потоку.
                        }
                    }

                    if(size > 0) { // Якщо в масиві є елементи
                        // Записуємо відсортовану послідовність у файл.
                        f << "\n\n\nУпорядковуємо надану послідовність за критерієм \"Спочатку гарні(позитивні) потім погані (негативні)\":\n"; // Виводимо повідомлення про впорядкування за певним критерієм.
                        for(int i = 0; i < size; i++) { // Проходимося по елементам масиву.
                            f << setw(10) << i + 1 << ". " << setw(10) << A[i]; // Записуємо елемент у файл.
                            if(i + 1 == size) f << ".\n"; // Якщо це останній елемент, додаємо крапку і переводимо рядок.
                            else f << ";\n"; // Інакше додаємо крапку з комою і переводимо рядок.
                        }
                        // Записуємо кількість позитивних, нульових та негативних чисел у файл.
                        f << "\nКількість гарних (позитивних): " << poz << ";\nКількість ніяких (нульових): " << zer << ";\nКількість поганих (негативних): " << neg << ".\n"; // Виводимо кількість позитивних, нульових та негативних чисел.
                    } else { // Інакше
                        f << "\nНемає елементів\n"; // Записуємо повідомлення про відсутність елементів у файлі.
                    }
                    f.close(); // Закриваємо файл.
                    break; // Вихід із циклу.
            }
        } while(choice != 'y' && choice != 'n'); // Повторюємо цикл, доки користувач не вибере 'y' або 'n'.
    }
    cout << "\nВихід...\n\n\n"; // Виводимо повідомлення про вихід.
}
