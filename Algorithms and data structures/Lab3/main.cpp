#include <iostream> // Підключення заголовкового файлу для вводу-виводу даних.
using namespace std; // Використання простору імен std.
int el; // Змінна, яка містить ціле число для елементів у списку.
double e; // Змінна, яка містить число число з подвійною точністю для перевірки вводу значень у списку.
bool read = true; // Змінна, яка містить істину та перевіряє який саме елемент будемо видаляти у списку: парний, непарний. 
struct element // Створюємо структуру яку оголошуємо через "element".
{
    int data; // Поле даних, в даному випадку – цілого типу.
    element* next; // Вказівник на наступний елемент списку.
};
void AddEnd(element* &List, element* New) // Функція, яка додає елемент у кінець списку. Вона приймає список та значенння нового елемента.
{
    if(List == nullptr) // Якщо перший елемент є пустим.
    {
        List = New; // Надаємо йому значення нового елемента.
    }
    else // Якщо перший елемент не є пустим.
    {
        element* node = List; // Створюємо копію списку.
        while(node->next != nullptr) // Поки наступний елемент не буде пустим (у копії).
        {
            node = node->next; // Переходимо до наступного елемента.
        }
        node->next = New; // Надаємо наступному елементу значення нового елемента.
    }
}
void AddStart(element* &List, element* New) // Функція, яка додає елемент у початок списку. Вона приймає список та значенння нового елемента.
{
    if(List == nullptr) // Якщо перший елемент є пустим.
    {
        List = New; // Надаємо йому значення нового елемента.
    }
    else // Якщо перший елемент не є пустим.
    {
        element* node = List; // Створюємо копію списку.
        New->next = List; // Те, що буде після "New" - буде наш список.
        List = New; // Перше значення листа буде "New".
    }
}
void AddElement(element* &List, int data) // Функція, яка додає елемент або в початок або в кінець, в залежності від парності елемента. Вона приймає список та ціле значенння.
{
    element* New = new element;  // Виділяємо памʼять під новий елемент.
    New->data = data; // Записуємо данні елемента.
    New->next = nullptr; // Первісно встановлюємо нульовий показник.

    if(data % 2 == 0) // Якщо елемент парний.
    {
        AddStart(List, New); // Додаємо елемент у початок списку.
    }
    else // Якщо елемент не парний.
    {
        AddEnd(List, New); // Додаємо елемент у кінець списку.
    }
}
void Add(element* &List)  // Функція, яка додає елемент, але перед цим перевіряє чи він правильно введений. Вона приймає список.
{
    cout << "\nВведіть ціле число: "; // Просимо ввести ціле число (елемент списку).
    while(true) // Поки істина.
    {
        cin >> e; // Вводимо значення, яке хочемо додати.
        el = e; // робимо це значення цілого виду.
        if (cin.fail() || el != e ) // Якщо введено не число або не ціле число.
        {
            cin.clear(); // Очищення потоку введення.
            cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Пропуск всіх символів до кінця рядка у введенні, якщо такі символи існують.
            cout << "\nBибачте, але це не ціле число.\nВведіть ціле число: "; // Виводимо повідомлення про некоректне введення.
        }
        else break; // Якщо цілий елемент введено коректно, то цикл перевірки закінчується.
    }
    AddElement(List, el); // Додаємо елемент або в початок або в кінець, в залежності від парності елемента.
}
void DisplayListWithIndices(element* &List) // Функція, яка елементи списку. Вона приймає список.
{
    element* Node = List; // Створюємо копію списку.
    if(Node == nullptr)  // Якщо перший елемент є пустим.
    {
        cout << "\nЛист порожній.\n"; // Виводимо повідомлення про те, що список порожній.
    }
    else // Якщо перший елемент не є пустим.
    {
        cout << "\nЕлементи та їх індекси:\n"; // Виводимо повідомлення про те, що буде виводитися.
        int index = 1; // Сворюємо змінну, яка відповідає за кількість елементі та надаємо значення "1".
        while (Node != nullptr)  // Поки елемент не буде пустим (у копії).
        {
            cout << "\n                        Елемент: " << Node->data << ", індекс: " << index ; // Виводимо елементи та індекси списку (копії).
            Node = Node->next; // Надаємо поточному значенню елемента - значення наступного елемента.
            index++; // Збільшуємо індекс на одиницю.
            if(Node != nullptr) cout << ";\n"; // Якщо список ще не пустий, то виводимо крапку з комою.
            else cout << ".\n"; // Якщо список пустий, то виводимо крапку.
        }
    }
}
void ElementFromIndex(element* &List, int index, element &elem) // Функція, яка знаходить елемент по індексу. Вона приймає список, номер індексу та елемент в який треба зберегти цей список.
{
    int counter = 1; // Сворюємо змінну, яка відповідає за кількість елементі та надаємо значення "1".
    element *current = List; // Створюємо копію списку.
    while (current != nullptr) // Поки елемент не буде пустим (у копії).
    {
        if (counter == index) // Якщо знаходимо елемент із індексом, який шукаємо по індексу.
        {
            elem = *current; // Надаємо нашій змінній значення елемента в списку.
            break; // Виходимо з циклу.
        }
        current = current->next; // Надаємо поточному значенню елемента - значення наступного елемента.
        counter++;  // Збільшуємо індекс на одиницю.
    }
}
void DeleteElementFromList(element* &List, int value) // Функція, яка видаляє елемент із списку. Вона приймає список та значення, яке треба видалити, але лише перше, яке зістріниться.
{
    element* current = List; // Створюємо копію списку.
    element* previous = nullptr; // Заголовок – вказівник на перший елемент списку та надання значення нуля.
    while (current != nullptr) // Поки елемент не буде пустим (у копії).
    {
        if (current->data == value) // якщо елемент, який потрібно видалити знайдено.
        {
            if (previous) // Якщо пустий елемент.
            {
                previous->next = current->next; // Додатковий список, наступний елемент у ньому, приймає значення наступного елемента у копії списку.
            }
            else  // Якщо не пустий елемент.
            {
                List = current->next; // Список приймає значення наступного елемента своєї копії.
            }
            delete current; // Видаляємо елемент у копії.
            break; // Виходимо із циклу.
        }
        previous = current; // Додатковий список приймає значення копії списка.
        current = current->next; // Надаємо поточному значенню елемента - значення наступного елемента (копії).
    }
}
void DeleteAtIndex(element* &List, int index) // Функція, яка видаляє елемент із списку по індексу. Вона приймає список та значення індекса аргумента, який потрібно видалити.
{
    if (List == nullptr)  // Якщо перший елемент є пустим.
    {
        return; // Закінчуємо функцію.
    }
    if (index == 0) // Якщо це перший елемент.
    {
        element *temp = List; // Створюємо копію списку.
        List = List->next; // Надаємо поточному значенню елемента - значення наступного елемента (копії).
        delete temp;  // Видаляємо елемент списка.
    } 
    else // Якщо це не перший елемент.
    {
        element *current = List; // Створюємо копію списку.
        for (int i = 0; current != nullptr && i < index - 1; i++) // Поки елемент не буде пустим (у копії).
        {
            current = current->next;  // Надаємо поточному значенню елемента - значення наступного елемента (копії).
        }
        if (current == nullptr || current->next == nullptr)  // Якщо дійсний або наступний елемент не буде пустим (у копії).
        {
            return; // Закінчуємо функцію.
        }
        element *temp = current->next; // Надаємо значення наступного елемента списку новому списку.
        current->next = current->next->next; // Надаємо наступному елементу значення, яке йде за ним.
        delete temp;  // Видаляємо елемент списка.
    }
}
bool CheckIfNumberExists(element* List, int number) // Функція, яка перевіряє чи є елемент у списку. Вона приймає список та значення, яке треба знайти.
{
    while (List != nullptr) // Поки лист не пустий.
    {
        if (List->data == number) // Якщо є такий елемент, який ми шукаємо.
        {
            return true; // Повертаємо істину.
        }
        List = List->next; // Надаємо поточному значенню елемента - значення наступного елемента.
    }
    return false; // Повертаємо неправду, бо такого елемента не знайшли у списку.
}
element Index(element* &List, int index, element &elem) // Функція, яка знаходить елемент у списку по індексу та зберігає у "elem". Вона приймає список, номер (індекс) елемента та змінну в яку запише знайдений елемент.
{
    element* Node = List; // Створюємо копію списку.
    int c = 0; // Створюємо топоміжний індекс елементів.
    while (Node != nullptr) // Поки лист не пустий (копія).
    {
        if(c==index) // Якщо є такий індекс.
        {
            elem.data = Node->data; // Змінна приймає значення елемента із цим індексом.
        }
        c++; // до індексу додається один.
        Node = Node->next; // Надаємо поточному значенню елемента - значення наступного елемента.
    }
    return elem;
}
void DeletElementbyList(element* &List) // Функція, яка видаляє елемент у списку: для парних варіантів – за номером елемента в списку; для непарних варіантів – за значенням. Вона приймає список.
{
    if(List == nullptr) // Якщо перший елемент є пустим.
    {
        cout << "\nЛист уже порожній. Неможливо видалити елемент, коли їх взагалі немає.\n"; // Виводимо повідомлення про вже порожній лист.
    }
    else // Якщо перший елемент не є пустим.
    {
        element* Node = List; // Створюємо копію списку.
        element elem; // Створюємо допоміжну змінну в яку будемо записувати елемент із списка, який визначемо по індексу.
        int index = 1; // Створюємо змінну, яка відповідає за кількість елементі та надаємо значення "1".
        bool corect = false; // Створюємо змінну, яка нам дасть знати, чи правильно введене число.
        while (Node != nullptr) // Поки елемент не буде пустим (у копії).
        {
            Node = Node->next; // Надаємо поточному значенню елемента - значення наступного елемента.
            index++; // Збільшуємо індекс на одиницю.
        }
        // Просимо сказати користувача який саме будемо видаляти елемент: парний - 2, непарний - 1.
        cout << "\nБудемо видаляти парний чи непарний елемент?\n";
        cout << "\n                                           - Якщо непарний - натисни \"1\".\n";
        cout << "\n                                           - Якщо парний - натисни \"2\";\n";
        
        cout << "\nВведіть свій вибір: "; // Просимо користувача ввести варіант.
        while(true) // Поки істина.
        {
            cin >> e; // Вводимо значення елемента.
            if (!cin) {} // Якщо це не число, то нічого не робимо.
            else if(e == 1.00){ read = false; break;} // Якщо введено цілу одиницю, то "read" приймає значення "false".
                 else if (e == 2.00) {read = true; break;} // Якщо введено цілу двійку, то "read" приймає значення "true".
            cin.clear(); // Очищення потоку введення.
            cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Пропуск всіх символів до кінця рядка у введенні, якщо такі символи існують.
            
            // Пишемо, що від некоректний, повторюємо умову та просимо ввести ще раз вибір.
            cout << "\nBибачте, але це не числа 1 чи 2.\n";
            cout << "\nБудемо видаляти парний чи непарний елемент?\n";
            cout << "\n                                           - Якщо непарний - натисни \"1\".\n";
            cout << "\n                                           - Якщо парний - натисни \"2\";\n";
            cout << "\nВведіть свій вибір: ";
        }
        if (read == true) // Якщо хочемо видалити парний елемент.
        {
            cin.clear(); // Очищення потоку введення.
            cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Пропуск всіх символів до кінця рядка у введенні, якщо такі символи існують.
            cout << "\nВведіть номер індекса цього елемента: "; // Просимо ввести індекс парного елемента у списку.
            cin >> e; // Вводимо значення індекса.
            el = e; // Надаємо значенню "int" значення введеного значення.
            if (cin.fail()) cout << "\nЦе взагалі не число.\n"; // Якщо введено взагалі не число, то виводимо відповідне повідомлення.
            else // Якщо введено число.
            {
                if (el == e) // Якщо значення "int" таке ж саме значення, що і "double".
                { 
                    if(el <= 0 || el > index-1) cout << "\nДоступні індекси в діапазоні [1; " << index-1 << "].\n"; // Якщо немає елемента з таким індексом, то говоримо, які є допустимі значення.
                    else corect = true; // Якщо є елемент з таким індексом, тоговоримо, що все коректно.
                }
                else cout << "\nЦе не натуральне число.\n"; // Якщо значення "int" не таке ж саме значення, що і "double", то виводимо повідомлення про те, що введено не натуральне число.
                cin.clear(); // Очищення потоку введення.
                cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Пропуск всіх символів до кінця рядка у введенні, якщо такі символи існують.
            }
            if (corect == true) // Якщо є елемент з таким індексом.
            {
                Index(List, (el-1), elem); // Знаходимо елемент по індексу.
                if (elem.data % 2 == 0) corect = true; // Якщо елемент парний, то все коректно.
                if (elem.data % 2 != 0) // Якщо елемент не парний.
                {
                    cout << "\nЦе не парний аргумент.\n"; // Говоримо, що це не парний елемент. 
                    corect = false; // Запамʼятовуємо, що значення некоректне.
                }
            }
            if (corect == true) // Якщо елемент парний.
            {
                DeleteAtIndex(List, el-1); // Видаляємо елемент по індексу.
                cout << "\nЕлемент видалено успішно.\n"; // Говоримо, що видалення пройшло успішно.
            }
            if (corect == false) cout << "\nЕлемент не видалено.\n"; // Якщо елемент не парний, то говоримо, що елемент не видалено.
        }
        if (read == false) // Якщо хочемо видалити не парний елемент.
        {
            cin.clear(); // Очищення потоку введення.
            cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Пропуск всіх символів до кінця рядка у введенні, якщо такі символи існують.
            cout << "\nВведіть цей елемент: "; // Просимо користувача ввести цей елемент, який хочемо видалити.
            cin >> e; // Вводимо значення індекса.
            el = e; // Надаємо значенню "int" значення введеного значення.
            if (cin.fail()) cout << "\nЦе взагалі не число.\n"; // Якщо введено взагалі не число, то виводимо відповідне повідомлення.
            else
            {
                if (el == e) // Якщо значення "int" таке ж саме значення, що і "double".
                {
                    bool exists = CheckIfNumberExists(List, el); // Створюємо змінну, яка приймає значення функції правда або брехня, чи є елемент в списку.
                    if (exists) corect = true; // Якщо елемент є в списку, то все коректно.
                    else cout << "\nТакого числа у списку немає.\n" << endl; // Якщо елемента немає в списку, то говоримо, що його немає.
                }
                else cout << "\nЦе не натуральне число.\n";  // Якщо значення "int" не таке ж саме значення, що і "double", то виводимо повідомлення про те, що введено не натуральне число.
                cin.clear(); // Очищення потоку введення.
                cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Пропуск всіх символів до кінця рядка у введенні, якщо такі символи існують.
            }
            if (corect == true) // Якщо є такий елемент.
            {
                if(el % 2 ==0) // Якщо він парний.
                {
                    cout << "\nЦе парний аргумент.\n"; // Говоримо, що це парний елемент.
                    corect = false; // Запамʼятовуємо, що значення некоректне.
                }
                if(el % 2 != 0) corect = true; // Якщо елемент не парний, то все коректно.
            }
            if (corect == true) // Якщо елемент не парний.
            {
                DeleteElementFromList(List, el); // Видаляємо елемент у списку за значенням (лише перший, який зустрівся).
                cout << "\nЕлемент видалено успішно.\n"; // Говоримо, що видалення пройшло успішно.
            }
            if (corect == false) cout << "\nЕлемент не видалено.\n"; // Якщо елемент парний, то говоримо, що елемент не видалено.
        }
    }
}
void Delet(element* &List)  // Функція, яка видаляє всі елементи списка. Вона приймає список.
{
    if(List == nullptr)  // Якщо перший елемент є пустим.
    {
        cout << "\nЛист уже порожній. Неможливо видалити всі елементи, коли їх взагалі немає.\n"; // Виводимо повідомлення про вже порожній лист.
    }
    else // Якщо перший елемент не є пустим.
    {
        while (List != nullptr) // Поки лист не пустий.
        {
            delete List; // Видаляємо елемент списка.
            List = List->next; // Надаємо поточному значенню елемента - значення наступного елемента.
        }
        cout << "\nBидалено всі елементи зі списку.\n"; // Виводимо повідомлення про видалення всіх елементів зі списку.
    }
}
void Task(element* List) // Функція, яка виконує дію x=(x-xmin), де х - кожне значення списку. Вона приймає список.
{
    element* Node = List; // Створюємо копію списку.
    if(Node == nullptr)  // Якщо перший елемент є пустим.
    {
        cout << "\nЛист порожній.\n"; // Виводимо повідомлення про те, що список порожній.
    }
    else // Якщо перший елемент не є пустим.
    {
        DisplayListWithIndices(List); // Виводимо список.
        element elem; // Створюємо якись елемент, такого ж типу, як елемент у списку.
        ElementFromIndex(List, 1, elem); // Надаємо цьому елементу значення першого елемента.
        int xmin = elem.data; // Надаємо змінній, яка відповідає за найменший елемент, значення першого елемента.
        while (Node != nullptr) // Поки елемент не буде пустим (у копії).
        {
            if (Node->data < xmin) // Якщо елемент менший за змінну, яка відповідає за найменший елемент.
            {
                xmin = Node->data; // Надаємо змінній, яка відповідає за найменший елемент, значення елемента меншого за нього самого.
            }
            Node = Node->next;  // Надаємо поточному значенню елемента - значення наступного елемента.
        }
        Node = List; // Оновлюємо копію списку.
        int min = xmin; // Створюємо копію найменшого значення.
        char pm = '-'; // Створюємо змінну, яка відповідатиме за значення плюс або мінус.
        cout << "\nМінімальне значення листа: " << min; // Виводимо мінімальне значення списку.
        if (min < 0) { min = -min; pm = '+';} // Якщо значення відʼємне, то змінна, яка відповідає за значення плюс або мінус, приймає значення плюс.
        cout << ".\nНехай кожен елемент у списку - це \"x\", тоді виконується умова \"x\" = \"x\" " << pm << " " << min << ".\n"; // Виводимо дію, яка виконується x=(x-xmin).
        while (Node != nullptr) // Поки елемент не буде пустим (у копії).
        {
            Node->data -= xmin; // елемент приймає своє значееня і від нього віднімається найменше значення.
            Node = Node->next; // Надаємо поточному значенню елемента - значення наступного елемента.
        }
        DisplayListWithIndices(List); // Виводимо отриманий список.
    }
}
void Exit() // Оголошення функції Exit без параметрів. Ця функція виводить повідомлення про завершення програми.
{
    cout << "\nВихід..." << "\n\n\n"; // Виводить повідомлення про вихід із програми.
}
void UnReal() // Оголошення функції UnReal без параметрів. Ця функція недозволяє програмі зациклитися при неправильному вводі користувача пунктів меню.
{
    cin.clear(); // Очищення потоку введення.
    cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Пропуск всіх символів до кінця рядка у введенні, якщо такі символи існують.
    cout << "\nНевірний вибір. Будь ласка спробуйте ще раз.\n"; // Виводить повідомлення про неправильний вибір і просить спробувати ще раз.
}
int main(int argc, char** argv) // Oголошення функції "main()", яка приймає параметри "argc" (кількість аргументів командного рядка) та "argv" (масив з аргументами командного рядка), і повертає ціле значення.
{
    double menu; // Визначення змінної "menu", яка містить число число з подвійною точністю для перевірки вводу пунктів меню.
    int fmenu; // Визначення змінної "fmenu", яка містить ціле число для вибору пунктів меню.
    element* Lhead = nullptr; // Заголовок – вказівник на перший елемент списку та надання значення нуля.
    do // Робити.
    {
        // Вивід пунктів меню.
        cout << "\nМеню:\n";
        cout << "     1. Додати елемент до списку\n";
        cout << "           −для парних варіантів – на початок списку;\n";
        cout << "           −для непарних варіантів – у кінець списку.\n";
        cout << "           Значення елементу, що додається, вводити з клавіатури.\n";
        cout << "     2. Видалити елемент зі списку.\n";
        cout << "           −для парних варіантів – за номером елемента в списку.\n";
        cout << "           Номер вводити з клавіатури;\n";
        cout << "           −для непарних варіантів – за значенням.\n";
        cout << "           Значення елементу вводити з клавіатури. Видалити перший елемент з заданим значенням, який зустрівся.\n";
        cout << "     3. Вивести елементи списку на екран.\n";
        cout << "     4. Очистити список (видалити всі елементи).\n";
        cout << "     5. Пункт щодо індивідуального завдання згідно з варіантом.\n";
        cout << "     6. Завершення роботи.\n";

        cout << "\nВведіть свій вибір: "; // Просимо користувача ввести пункт меню, який він хоче виконати.
        cin >> menu; // Ввід пункта меню.
        fmenu = menu; // Перевірка вводу на ціле число
        if (fmenu == menu) {} // Перевірка вводу на ціле число.
        else fmenu = -1; // Якщо не ціле число чи взагалі якась маячня, то пункт меню надає значення "-1".
        switch (fmenu)  // Перехід до відповідного варіанту в залежності від вибору користувача.
        {
            case 1: // Якщо введено "1".
                    Add(Lhead); // Функція додає елемент до списку.
                    break; // Завершення виконання case 1.
            case 2: // Якщо введено "2".
                    DeletElementbyList(Lhead); // функція видаляє елемент зі списку.
                    break; // Завершення виконання case 2.
            case 3: // Якщо введено "3".
                    DisplayListWithIndices(Lhead); // Функція виводить елементи списку.
                    break; // Завершення виконання case 3.
            case 4: // Якщо введено "4".
                    Delet(Lhead); // Функція видаляє всі елементи списку.
                    break; // Завершення виконання case 4.
            case 5: // Якщо введено "5".
                    Task(Lhead); // Функція виконує індивідуальне завдання.
                    break; // Завершення виконання case 5.
            case 6: // Якщо введено "6".
                    Exit(); // Функція завершує роботу программи.
                    break; // Завершення виконання case 6.
            default: // Інші випадки.
                    UnReal(); // Функція обробляє нереалізовані пункти.
                    break; // Завершення виконання default.
        }
        cout << "\n";
    }while(menu!=6); // Повторення циклу, доки користувач не вибере пункт 6 (завершення роботи).
    return 0; // Повертається значення 0 для позначення успішного завершення програми.
}